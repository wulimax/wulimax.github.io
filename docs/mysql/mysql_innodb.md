## innodb具有高并发, 事物 ,数据安全等特性

1.二叉树 平衡树 多叉树

首先我们先了解一下树的概念: 

<img src="/docs/mysql/image/tree.png" height="330" width="495">

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -> UserC -> UserF -> User2 这个路 径得到。这个时间复杂度是 O(log(N))。

**普通的二叉树适用场景查询比较多的情况,但是对于一个经常需要增删改的场景就显得有点鸡肋了** 

这时候你就需要保持这棵树是平衡二叉树。为了做这个保 证，更新的时间复杂度也是 O(log(N))。
树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右 递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因 是，索引不止存在内存中，还要写到磁盘上。

想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据 块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于 一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间， 这个查询可真够慢的。
为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该 使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。
以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以 存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行 的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很 大概率在内存中，那么访问磁盘的平均次数就更少

2.索引

​     主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引, 

​      为什么要进行逻辑删除而不要物理删除: a.公司业务需要  b.对表主键进行删除 修改操作会触发页的分裂合并 不建议用

​      为什么要尽量用主键索引: 数据存在于主键索引上 使用普通索引会触发回表 ,可以使用覆盖索引优化

​      force index 可以矫正优化器的选择

<img src="/docs/mysql/image/tree_1.png" height="330" width="495">

​    可以看出在b+树中,叶子节点会指向他相邻的叶子节点,这样可以有效减少遍历次数

3.锁

​      全局锁: 一般用于数据库备份; 表锁 行锁

   **两阶段锁协议**，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态

 **时间戳排序协议**，每个事务都有一个唯一的时间戳，也就是其进入系统的时间。时间戳有大小之分，如果事务Ti比Tj先进入系统，则TS(Ti)<TS(Tj)。对于每个数据项Q，有两个时间戳与其绑定：一个是W-TS(Q)，表示最近一次写数据项Q的事务的时间戳；一个是R-TS(Q)，表示最近一次读数据项Q的事务的时间戳。Thomas协议是对时间戳排序协议的改进，具体内容如下：

若事务Ti发起一个write(Q)，则

如果TS(Ti)<R-TS(Q)，则表明Ti准备写的值还没来得及写入，Q就提前被读取了，所以Ti的write(Q)操作被拒绝，并且事务Ti被回滚。

如果TS(Ti)<W-TS(Q)，表明Ti写的值已过期，比它更新的值已经写到Q上，所以Ti的write(Q)操作被拒绝。

剩下的情况，write(Q)操作被允许

**树形协议**，假设数据项的集合满足一个偏序关系，访问数据项必须按此偏序关系的先后进行。如di->dj，则要想访问dj，必须先访问di。这种偏序关系导出一个有向无环图(DAG)，因此称为树形协议。树形协议的规则有：

树形协议只有独占锁；

事务T第一次加锁可以对任何数据项进行； 

此后，事务T对数据项Q的加锁前提是持有Q的父亲数据项的锁； 

对数据项的解锁可以随时进行； 

数据项被事务T加锁并解锁之后，就不能再被事务T加锁。 

树形协议的优点是并发度好，因为可以较早地解锁。并且没有死锁，因为其加锁都是顺序进行的。 

缺点是对不需要访问的数据进行不必要的加锁

3.redu log

​       当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到 磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”。 InnoDB 的 redo log 写满了。这时候系统会停止所有更新操作，把 checkpoint 往前推进，redo log 留出空间可以继续写。redo log是循环写    

​         InnoDB 每次写入的日志都有一个序号，当前写入的序号跟 checkpoint 对应的序号之间的差 值，我们假设为 N。InnoDB 会根据这个 N 算出一个范围在 0 到 100 之间的数字，这个计算公 式可以记为 F2(N)。F2(N) 算法比较复杂，你只要知道 N 越大，算出来的值越大就好了。
然后，根据上述算得的 F1(M) 和 F2(N) 两个值，取其中较大的值记为 R，之后引擎就可以按照 innodb_io_capacity 定义的能力乘以 R% 来控制刷脏页的速度的

​       <img src="/docs/mysql/image/redulog.png" height="330" width="495">

一旦一个查询请求需要在执行过程中先 flush 掉一个脏页时，这个查询就可能要比平时慢了。而 MySQL 中的一个机制，可能让你的查询会更慢：在准备刷一个脏页的时候，如果这个数据页旁 边的数据页刚好是脏页，就会把这个“邻居”也带着一起刷掉；而且这个把“邻居”拖下水的逻 辑还可以继续蔓延，也就是对于每个邻居数据页，如果跟它相邻的数据页也还是脏页的话，也会 被放到一起刷。
在 InnoDB 中，innodb_flush_neighbors 参数就是用来控制这个行为的，值为 1 的时候会有上 述的“连坐”机制，值为 0 时表示不找邻居，自己刷自己的。
找“邻居”这个优化在机械硬盘时代是很有意义的，可以减少很多随机 IO。机械硬盘的随机 IOPS 一般只有几百，相同的逻辑操作减少随机 IO 就意味着系统性能的大幅度提升。
而如果使用的是 SSD 这类 IOPS 比较高的设备的话，我就建议你把 innodb_flush_neighbors 的值设置成 0。因为这时候 IOPS 往往不是瓶颈，而“只刷自己”，就能更快地执行完必要的刷 脏页操作，减少 SQL 语句响应时间。
在 MySQL 8.0 中，innodb_flush_neighbors 参数的默认值已经是 0 了

查询磁盘写能力设置 

show global variables like '%capacity%';

innodb_io_capacity	200
innodb_io_capacity_max	2000

设置磁盘写能力 set global innodb_io_capacity=2000;

| innodb_io_capacity | 磁盘配置         |
| ------------------ | ---------------- |
| 200                | 单盘SAS/SATA     |
| 2000               | SAS*12  RAID  10 |
| 5000               | SSD              |
| 50000              | FUSION-IO        |

4. count()

     有朋友问我count()是怎么回事;

   对于 count(主键 id) 来说，

   ​                 InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
   对于 count(1) 来说，

   ​                 InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一 个数字“1”进去，判断是不可能为空的，按行累加。
   单看这两个用法的差别的话，你能对比出来，count(1) 执行得要比 count(主键 id) 快。因为从 引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。
   对于 count(字段) 来说：

   1. 如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能 为 null，按行累加；
   2. 如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出 来再判断一下，不是 null 才累加。
     也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。
     但是 count(*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定 不是 null，按行累加

​      结论: 按照效率排序的话，count(字段)<count(主键 id)<count(1)≈count( * )，所以我 建议你，尽量使用 count( * );