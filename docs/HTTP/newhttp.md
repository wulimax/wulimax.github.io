HTTP -> QUIC协议之ORTT加密传输

在了解这个协议前我们先了解一下http近些年来的发展情况

一 http/1

1. http1.x 

   ​       缺陷:线程阻塞,同一时间 同一域名的请求数量限制超过限制数目会被阻塞 链接无法复用  header头携带内容过大增加传输成本 传输都是明文数据无法保证安全性

2. http1.0 

   ​          缺陷:游览器于服务器只保持短暂的链接 游览器每次都需要建立TCP链接 新建成本很高 规定新建请求必须`request-response`才能新建链接 ,可能发送阻塞

3. http1.1 

   ​      引入持久链接 即TCP默认不关闭,可以被多个请求复用,不用声明 Connoction : keep-alive 大多数游览器支持同时建立6个链接 --链接是顺序执行的也就意味着会发生阻塞

   ​       管道机制:同一个TCP客户端可以发起多个请求

   ​       分块传输: 即服务器产生一块就发送一块

4. http2.0 

   ​	 http2.0基于 SPDY3 专注性能 对header进行压缩  采用二进制传输数据 比起http1.x文本传输更高效

   ​       SPDY增加了一个帧层用于多路复用，多个并发流通过一个TCP连接（或者其他可靠传输流）。这个帧层为类似HTTP的请求响应流进行了优化，现在运行在HTTP之上的应用也能运行在SPDY之上，对web应用开发者来说几乎不需要做什么改变。

   SPDY会话在HTTP的基础之上提供了四项改进：

   ​	多路复用请求：在单个SPDY连接能并发的发起请求，并不限制请求数；
   ​	请求优先级：客户端能请求某个资源被优先传输。这避免了高优先级请求被非关键资源堵塞网络通道的问题；
   ​	头部压缩：客户端现在发送了大量冗余的HTTP头部信息。因为一个页面可能有50到100个子请求，这些数据是巨大的；
   ​	服务端推送流：服务端能向客户端推送数据不需要客户端发起一个请求。

   SPDY视图保持已有的HTTP语义。所有的特性比如cookies，Etags，Vary headers，Content-Encoding协商，SPDY仅仅替换了网络数据传输方法。

   ​         SPDY是在会话层做出的改变 所有不会影响应用层http 

5. http3.0 

   ​      http3.0 原生支持多路复用,http2是基于TCP的多路复用

   ​     相对安全 所有header body 都加密

   ​     向前纠错 一两个包出现异常也可以通过其他包解开,减少网络开销

​               Google搞了一个基于UDP协议的QUIC协议,并应用在http3上 QUIC使用ORTT建立连接

 所谓的ORTT就是,通信双方通信连接时,第一个数据包便可以携带有效的业务数据数据

​            对于http而言需要三次握手 客户端发送SYN->服务员器, 服务器确定发送SYN确认包/ACK验证包->客户端,客户端发送ACK确认包->服务端

​           对于https而言除了三次握手还需要额外的TLS握手

​         ORTT 使用DH算法进行做秘钥协商

​          Step 0：配置服务器密钥对

​                     在生成一个素数和一个整数(是的一个原根，不懂可略过)，同时随机生成一个数，计算：

​                     将三元组打成一个config包。

​           Step 1：首次发起连接

​                      简单地发送Client Hello到。

​          Step 2：首次回应

​                             用config封装成一个数据包回复给，显然内含有元组。

​       Step 3：发送加密数据

​                     收到后随机生成一个数做如下计算：  
​                   计算公钥： 
​                    计算对称密钥：
​                    准备业务数据payload1，设加密函数为，将下列元组发送给： 

​                       注意，该阶段开始，payload便是加密的了。

​      Step 4：发送加密数据

​                  收到后，做以下计算： 
​                计算对称密钥： 
​                 可以证明，和端的是相等的： 

​                  因此可解密密文获取明文payload。

​                 也许你会觉得就可以做此后通信的对称密钥了吧，然而并不是。为了所谓的前向安全性，此时会继续生成第二个对称密钥
​                 在发送自己的payload2之前，随机生成一个数，做如下计算： 
​                 计算新的通信公钥： 
​                 计算新的通信对称密钥： 
​                  有了新的通信对称密钥，就可以将下面的元组发送给了： 

​                  这个元组中除了包含的加密数据之外，还包括新生成的一个公钥。

Step 5：收到的

​                收到发来的后，解出其中的，做如下运算： 
​               计算新的通信密钥：(可以证明) 
​               用可以正确解密出payload2。 
​                   此后的通讯，和便可以用做通信对称密钥了。

值得注意的是，这个是在1个RTT内新生成的，虽然耗费了1个RTT协商出了这个，但是在这个RTT中业务数据却依然可以加密通信的，只不过使用的是，即使用记忆中的端配置协商出的一个“不安全”的密钥，该密钥仅仅加密一趟数据。

​      Step 6：和断开连接 
​                和之间通信一会儿后，断开连接。 

​      Step 7：直接发送加密数据 
​                   过了一会儿或者一段时间后，又想和通信，注意，此时已经有了的config元组，也许是缓存在内存了，也许是写入磁盘了，无论怎样，只要拥有，它就可以直接从Step 3开始了，也就是说直接通过以及自己生成的随机数私钥计算出一个对称密钥，然后直接发送payload了。 
嗯，这就是所谓的0RTT。

Step 8：发送加密数据 

​          这里在收到的加密数据后，重复Step 4重新计算出一个新的“安全对称密钥”即可将之作为直至断开为止的对称密钥。



​       